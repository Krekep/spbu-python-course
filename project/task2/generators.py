from typing import Callable, Generator, TypeVar, Iterable, Optional
from functools import reduce

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

def make_data_generator(data: Iterable[T]) -> Generator[T, None, None]:
    """
    Creates a generator based on an iterable object.

    Parameters:
        data : Iterable[Any] (Input iterable object such as list, range, tuple, etc.)

    Returns:
        Generator[Any, None, None]: Generator yielding elements one-by-one from the given iterable.
    """
    yield from data

def compose_steps(source: Generator[T, None, None],
                  transformations: list[Callable[[Generator[T, None, None]], Generator[U, None, None]]]
                 ) -> Generator[U, None, None]:
    """
    Composes transformation steps sequentially applied to the data source.

    Parameters:
        source : Generator[T, None, None] (Source data generator)
        transformations : List[Callable[[Generator[T, None, None]], Generator[U, None, None]]] (List of transformation functions)

    Returns:
        Generator[U, None, None]: Resulting generator after applying all transformations.
    """
    stream = source
    for transform in transformations:
        stream = transform(stream)
    return stream

def aggregate_results(stream: Generator[V, None, None], accumulator: Callable[[Iterable[V]], U]) -> U:
    """
    Aggregates the results produced by the generator into a single value.

    Parameters:
        generator : Generator[V, None, None] (Generator producing values)
        accumulator : Callable[[Iterable[V]], U] (Function that collects the output)

    Returns:
        U: Final aggregated result collected via the provided accumulator.
    """
    return accumulator(stream)

def apply_map(transform: Callable[[T], V]) -> Callable[[Generator[T, None, None]], Generator[V, None, None]]:
    """
    Applies a mapping transformation to each element of the generator.

    Parameters:
        transform : Callable[[T], V] (Transformation function)

    Returns:
        Callable[[Generator[T, None, None]], Generator[V, None, None]]: Function wrapping the transformation logic.
    """
    return lambda gen: (transform(item) for item in gen)

def apply_filter(predicate: Callable[[T], bool]) -> Callable[[Generator[T, None, None]], Generator[T, None, None]]:
    """
    Filters out elements from the generator based on a condition.

    Parameters:
        predicate : Callable[[T], bool] (Predicate function determining whether to keep an element)

    Returns:
        Callable[[Generator[T, None, None]], Generator[T, None, None]]: Filtered generator function.
    """
    return lambda gen: (item for item in gen if predicate(item))

def apply_reduce(reduction: Callable[[Optional[V], T], V], initial: Optional[V]=None) -> Callable[[Generator[T, None, None]], V]:
    """
    Reduces the sequence of values generated by reducing them into a single result.

    Parameters:
        reduction : Callable[[Optional[V], T], V] (Reduction function combining elements)
        initial : Optional[V] (Initial value for reduction)

    Returns:
        Callable[[Generator[T, None, None]], V]: Reduction function wrapper.
    """
    return lambda gen: reduce(reduction, gen, initial)

def apply_zip(other_gen: Generator[U, None, None]) -> Callable[[Generator[T, None, None]], Generator[tuple[T, U], None, None]]:
    """
    Zips together two generators creating pairs of corresponding elements.

    Parameters:
        other_gen : Generator[U, None, None] (Second generator to combine with)

    Returns:
        Callable[[Generator[T, None, None]], Generator[Tuple[T, U], None, None]]: Zipped generator function.
    """
    return lambda gen: ((x, y) for x, y in zip(gen, other_gen))

# Демонстрация использования

if __name__ == "__main__":
    # Создание генератора данных
    numbers = make_data_generator(range(10))

    # Составление серии операций
    transformations = [
        apply_map(lambda x: x * 2),  # Удваиваем число
        apply_filter(lambda x: x > 5),  # Оставляем только числа больше пяти
        apply_reduce(lambda acc, x: acc + x, 0)  # Суммируем оставшиеся числа
    ]

    # Получение результата
    final_result = aggregate_results(compose_steps(numbers, transformations), lambda x: x)
    print(final_result)  # сумма удвоенных чисел от 0 до 9, которые больше 5