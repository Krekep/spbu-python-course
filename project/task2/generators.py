from typing import Callable, Generator, TypeVar, Iterable, Optional, Any
from functools import reduce

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")


def make_data_generator(data: Iterable[T]) -> Generator[T, None, None]:
    """
    Creates a generator based on an iterable object.

    Parameters:
        data : Iterable[Any] (Input iterable object such as list, range, tuple, etc.)

    Returns:
        Generator[Any, None, None]: Generator yielding elements one-by-one from the given iterable.
    """
    yield from data


def compose_steps(
    source: Generator[T, None, None],
    transformations: list[
        Callable[[Generator[Any, None, None]], Generator[Any, None, None]]
    ],
) -> Generator[Any, None, None]:
    """
    Composes transformation steps sequentially applied to the data source.

    Parameters:
        source : Generator[T, None, None] (Source data generator)
        transformations : List[Callable[[Generator[T, None, None]], Generator[U, None, None]]] (List of transformation functions)

    Returns:
        Generator[U, None, None]: Resulting generator after applying all transformations.
    """
    stream: Generator[Any, None, None] = source
    for transform in transformations:
        stream = transform(stream)
    return stream


def aggregate_results(
    stream: Generator[V, None, None], accumulator: Callable[[Iterable[V]], U]
) -> U:
    """
    Aggregates the results produced by the generator into a single value.

    Parameters:
        generator : Generator[V, None, None] (Generator producing values)
        accumulator : Callable[[Iterable[V]], U] (Function that collects the output)

    Returns:
        U: Final aggregated result collected via the provided accumulator.
    """
    return accumulator(stream)


def apply_map(
    transform: Callable[[T], V]
) -> Callable[[Generator[T, None, None]], Generator[V, None, None]]:
    """
    Applies a mapping transformation to each element of the generator.

    Parameters:
        transform : Callable[[T], V] (Transformation function)

    Returns:
        Callable[[Generator[T, None, None]], Generator[V, None, None]]: Function wrapping the transformation logic.
    """
    return lambda gen: (transform(item) for item in gen)


def apply_filter(
    predicate: Callable[[T], bool]
) -> Callable[[Generator[T, None, None]], Generator[T, None, None]]:
    """
    Filters out elements from the generator based on a condition.

    Parameters:
        predicate : Callable[[T], bool] (Predicate function determining whether to keep an element)

    Returns:
        Callable[[Generator[T, None, None]], Generator[T, None, None]]: Filtered generator function.
    """
    return lambda gen: (item for item in gen if predicate(item))


def apply_reduce(
    reduction: Callable[[Optional[V], T], V], initial: Optional[V] = None
) -> Callable[[Generator[T, None, None]], Optional[V]]:
    """
    Reduces the sequence of values generated by reducing them into a single result.

    Parameters:
        reduction : Callable[[Optional[V], T], V] (Reduction function combining elements)
        initial : Optional[V] (Initial value for reduction)

    Returns:
        Callable[[Generator[T, None, None]], V]: Reduction function wrapper.
    """
    return lambda gen: reduce(reduction, gen, initial)


def apply_zip(
    other_gen: Generator[U, None, None]
) -> Callable[[Generator[T, None, None]], Generator[tuple[T, U], None, None]]:
    """
    Zips together two generators creating pairs of corresponding elements.

    Parameters:
        other_gen : Generator[U, None, None] (Second generator to combine with)

    Returns:
        Callable[[Generator[T, None, None]], Generator[Tuple[T, U], None, None]]: Zipped generator function.
    """
    return lambda gen: ((x, y) for x, y in zip(gen, other_gen))
